{"version":3,"file":"703.extension.js","mappings":"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","sources":["webpack://writedot/./node_modules/@smithy/node-http-handler/dist-es/constants.js","webpack://writedot/./node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js","webpack://writedot/./node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js","webpack://writedot/./node_modules/@smithy/node-http-handler/dist-es/set-request-timeout.js","webpack://writedot/./node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js","webpack://writedot/./node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js","webpack://writedot/./node_modules/@smithy/util-stream/dist-es/stream-type-check.js","webpack://writedot/./node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js","webpack://writedot/./node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js","webpack://writedot/./node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js","webpack://writedot/./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/retry-wrapper.js","webpack://writedot/./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/fromHttp.js","webpack://writedot/./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/checkUrl.js","webpack://writedot/./node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/requestHelpers.js"],"sourcesContent":["export const NODEJS_TIMEOUT_ERROR_CODES = [\"ECONNRESET\", \"EPIPE\", \"ETIMEDOUT\"];\n","import { HttpResponse } from \"@smithy/protocol-http\";\nimport { buildQueryString } from \"@smithy/querystring-builder\";\nimport { Agent as hAgent, request as hRequest } from \"http\";\nimport { Agent as hsAgent, request as hsRequest } from \"https\";\nimport { NODEJS_TIMEOUT_ERROR_CODES } from \"./constants\";\nimport { getTransformedHeaders } from \"./get-transformed-headers\";\nimport { setConnectionTimeout } from \"./set-connection-timeout\";\nimport { setRequestTimeout } from \"./set-request-timeout\";\nimport { setSocketKeepAlive } from \"./set-socket-keep-alive\";\nimport { setSocketTimeout } from \"./set-socket-timeout\";\nimport { timing } from \"./timing\";\nimport { writeRequestBody } from \"./write-request-body\";\nexport const DEFAULT_REQUEST_TIMEOUT = 0;\nexport class NodeHttpHandler {\n    config;\n    configProvider;\n    socketWarningTimestamp = 0;\n    externalAgent = false;\n    metadata = { handlerProtocol: \"http/1.1\" };\n    static create(instanceOrOptions) {\n        if (typeof instanceOrOptions?.handle === \"function\") {\n            return instanceOrOptions;\n        }\n        return new NodeHttpHandler(instanceOrOptions);\n    }\n    static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {\n        const { sockets, requests, maxSockets } = agent;\n        if (typeof maxSockets !== \"number\" || maxSockets === Infinity) {\n            return socketWarningTimestamp;\n        }\n        const interval = 15_000;\n        if (Date.now() - interval < socketWarningTimestamp) {\n            return socketWarningTimestamp;\n        }\n        if (sockets && requests) {\n            for (const origin in sockets) {\n                const socketsInUse = sockets[origin]?.length ?? 0;\n                const requestsEnqueued = requests[origin]?.length ?? 0;\n                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {\n                    logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.\nSee https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html\nor increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);\n                    return Date.now();\n                }\n            }\n        }\n        return socketWarningTimestamp;\n    }\n    constructor(options) {\n        this.configProvider = new Promise((resolve, reject) => {\n            if (typeof options === \"function\") {\n                options()\n                    .then((_options) => {\n                    resolve(this.resolveDefaultConfig(_options));\n                })\n                    .catch(reject);\n            }\n            else {\n                resolve(this.resolveDefaultConfig(options));\n            }\n        });\n    }\n    resolveDefaultConfig(options) {\n        const { requestTimeout, connectionTimeout, socketTimeout, socketAcquisitionWarningTimeout, httpAgent, httpsAgent, throwOnRequestTimeout, } = options || {};\n        const keepAlive = true;\n        const maxSockets = 50;\n        return {\n            connectionTimeout,\n            requestTimeout,\n            socketTimeout,\n            socketAcquisitionWarningTimeout,\n            throwOnRequestTimeout,\n            httpAgent: (() => {\n                if (httpAgent instanceof hAgent || typeof httpAgent?.destroy === \"function\") {\n                    this.externalAgent = true;\n                    return httpAgent;\n                }\n                return new hAgent({ keepAlive, maxSockets, ...httpAgent });\n            })(),\n            httpsAgent: (() => {\n                if (httpsAgent instanceof hsAgent || typeof httpsAgent?.destroy === \"function\") {\n                    this.externalAgent = true;\n                    return httpsAgent;\n                }\n                return new hsAgent({ keepAlive, maxSockets, ...httpsAgent });\n            })(),\n            logger: console,\n        };\n    }\n    destroy() {\n        this.config?.httpAgent?.destroy();\n        this.config?.httpsAgent?.destroy();\n    }\n    async handle(request, { abortSignal, requestTimeout } = {}) {\n        if (!this.config) {\n            this.config = await this.configProvider;\n        }\n        return new Promise((_resolve, _reject) => {\n            const config = this.config;\n            let writeRequestBodyPromise = undefined;\n            const timeouts = [];\n            const resolve = async (arg) => {\n                await writeRequestBodyPromise;\n                timeouts.forEach(timing.clearTimeout);\n                _resolve(arg);\n            };\n            const reject = async (arg) => {\n                await writeRequestBodyPromise;\n                timeouts.forEach(timing.clearTimeout);\n                _reject(arg);\n            };\n            if (abortSignal?.aborted) {\n                const abortError = new Error(\"Request aborted\");\n                abortError.name = \"AbortError\";\n                reject(abortError);\n                return;\n            }\n            const isSSL = request.protocol === \"https:\";\n            const headers = request.headers ?? {};\n            const expectContinue = (headers.Expect ?? headers.expect) === \"100-continue\";\n            let agent = isSSL ? config.httpsAgent : config.httpAgent;\n            if (expectContinue && !this.externalAgent) {\n                agent = new (isSSL ? hsAgent : hAgent)({\n                    keepAlive: false,\n                    maxSockets: Infinity,\n                });\n            }\n            timeouts.push(timing.setTimeout(() => {\n                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, config.logger);\n            }, config.socketAcquisitionWarningTimeout ?? (config.requestTimeout ?? 2000) + (config.connectionTimeout ?? 1000)));\n            const queryString = buildQueryString(request.query || {});\n            let auth = undefined;\n            if (request.username != null || request.password != null) {\n                const username = request.username ?? \"\";\n                const password = request.password ?? \"\";\n                auth = `${username}:${password}`;\n            }\n            let path = request.path;\n            if (queryString) {\n                path += `?${queryString}`;\n            }\n            if (request.fragment) {\n                path += `#${request.fragment}`;\n            }\n            let hostname = request.hostname ?? \"\";\n            if (hostname[0] === \"[\" && hostname.endsWith(\"]\")) {\n                hostname = request.hostname.slice(1, -1);\n            }\n            else {\n                hostname = request.hostname;\n            }\n            const nodeHttpsOptions = {\n                headers: request.headers,\n                host: hostname,\n                method: request.method,\n                path,\n                port: request.port,\n                agent,\n                auth,\n            };\n            const requestFunc = isSSL ? hsRequest : hRequest;\n            const req = requestFunc(nodeHttpsOptions, (res) => {\n                const httpResponse = new HttpResponse({\n                    statusCode: res.statusCode || -1,\n                    reason: res.statusMessage,\n                    headers: getTransformedHeaders(res.headers),\n                    body: res,\n                });\n                resolve({ response: httpResponse });\n            });\n            req.on(\"error\", (err) => {\n                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {\n                    reject(Object.assign(err, { name: \"TimeoutError\" }));\n                }\n                else {\n                    reject(err);\n                }\n            });\n            if (abortSignal) {\n                const onAbort = () => {\n                    req.destroy();\n                    const abortError = new Error(\"Request aborted\");\n                    abortError.name = \"AbortError\";\n                    reject(abortError);\n                };\n                if (typeof abortSignal.addEventListener === \"function\") {\n                    const signal = abortSignal;\n                    signal.addEventListener(\"abort\", onAbort, { once: true });\n                    req.once(\"close\", () => signal.removeEventListener(\"abort\", onAbort));\n                }\n                else {\n                    abortSignal.onabort = onAbort;\n                }\n            }\n            const effectiveRequestTimeout = requestTimeout ?? config.requestTimeout;\n            timeouts.push(setConnectionTimeout(req, reject, config.connectionTimeout));\n            timeouts.push(setRequestTimeout(req, reject, effectiveRequestTimeout, config.throwOnRequestTimeout, config.logger ?? console));\n            timeouts.push(setSocketTimeout(req, reject, config.socketTimeout));\n            const httpAgent = nodeHttpsOptions.agent;\n            if (typeof httpAgent === \"object\" && \"keepAlive\" in httpAgent) {\n                timeouts.push(setSocketKeepAlive(req, {\n                    keepAlive: httpAgent.keepAlive,\n                    keepAliveMsecs: httpAgent.keepAliveMsecs,\n                }));\n            }\n            writeRequestBodyPromise = writeRequestBody(req, request, effectiveRequestTimeout, this.externalAgent).catch((e) => {\n                timeouts.forEach(timing.clearTimeout);\n                return _reject(e);\n            });\n        });\n    }\n    updateHttpClientConfig(key, value) {\n        this.config = undefined;\n        this.configProvider = this.configProvider.then((config) => {\n            return {\n                ...config,\n                [key]: value,\n            };\n        });\n    }\n    httpHandlerConfigs() {\n        return this.config ?? {};\n    }\n}\n","import { timing } from \"./timing\";\nconst DEFER_EVENT_LISTENER_TIME = 1000;\nexport const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {\n    if (!timeoutInMs) {\n        return -1;\n    }\n    const registerTimeout = (offset) => {\n        const timeoutId = timing.setTimeout(() => {\n            request.destroy();\n            reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${timeoutInMs} ms.`), {\n                name: \"TimeoutError\",\n            }));\n        }, timeoutInMs - offset);\n        const doWithSocket = (socket) => {\n            if (socket?.connecting) {\n                socket.on(\"connect\", () => {\n                    timing.clearTimeout(timeoutId);\n                });\n            }\n            else {\n                timing.clearTimeout(timeoutId);\n            }\n        };\n        if (request.socket) {\n            doWithSocket(request.socket);\n        }\n        else {\n            request.on(\"socket\", doWithSocket);\n        }\n    };\n    if (timeoutInMs < 2000) {\n        registerTimeout(0);\n        return 0;\n    }\n    return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);\n};\n","import { timing } from \"./timing\";\nexport const setRequestTimeout = (req, reject, timeoutInMs = 0, throwOnRequestTimeout, logger) => {\n    if (timeoutInMs) {\n        return timing.setTimeout(() => {\n            let msg = `@smithy/node-http-handler - [${throwOnRequestTimeout ? \"ERROR\" : \"WARN\"}] a request has exceeded the configured ${timeoutInMs} ms requestTimeout.`;\n            if (throwOnRequestTimeout) {\n                const error = Object.assign(new Error(msg), {\n                    name: \"TimeoutError\",\n                    code: \"ETIMEDOUT\",\n                });\n                req.destroy(error);\n                reject(error);\n            }\n            else {\n                msg += ` Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.`;\n                logger?.warn?.(msg);\n            }\n        }, timeoutInMs);\n    }\n    return -1;\n};\n","import { timing } from \"./timing\";\nconst DEFER_EVENT_LISTENER_TIME = 3000;\nexport const setSocketTimeout = (request, reject, timeoutInMs = 0) => {\n    const registerTimeout = (offset) => {\n        const timeout = timeoutInMs - offset;\n        const onTimeout = () => {\n            request.destroy();\n            reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${timeoutInMs} ms of inactivity (configured by client requestHandler).`), { name: \"TimeoutError\" }));\n        };\n        if (request.socket) {\n            request.socket.setTimeout(timeout, onTimeout);\n            request.on(\"close\", () => request.socket?.removeListener(\"timeout\", onTimeout));\n        }\n        else {\n            request.setTimeout(timeout, onTimeout);\n        }\n    };\n    if (0 < timeoutInMs && timeoutInMs < 6000) {\n        registerTimeout(0);\n        return 0;\n    }\n    return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);\n};\n","import { timing } from \"./timing\";\nconst DEFER_EVENT_LISTENER_TIME = 3000;\nexport const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME) => {\n    if (keepAlive !== true) {\n        return -1;\n    }\n    const registerListener = () => {\n        if (request.socket) {\n            request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);\n        }\n        else {\n            request.on(\"socket\", (socket) => {\n                socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);\n            });\n        }\n    };\n    if (deferTimeMs === 0) {\n        registerListener();\n        return 0;\n    }\n    return timing.setTimeout(registerListener, deferTimeMs);\n};\n","export const isReadableStream = (stream) => typeof ReadableStream === \"function\" &&\n    (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);\nexport const isBlob = (blob) => {\n    return typeof Blob === \"function\" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);\n};\n","import { streamCollector } from \"@smithy/fetch-http-handler\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { toHex } from \"@smithy/util-hex-encoding\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { isReadableStream } from \"./stream-type-check\";\nconst ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = \"The stream has already been transformed.\";\nexport const sdkStreamMixin = (stream) => {\n    if (!isBlobInstance(stream) && !isReadableStream(stream)) {\n        const name = stream?.__proto__?.constructor?.name || stream;\n        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);\n    }\n    let transformed = false;\n    const transformToByteArray = async () => {\n        if (transformed) {\n            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);\n        }\n        transformed = true;\n        return await streamCollector(stream);\n    };\n    const blobToWebStream = (blob) => {\n        if (typeof blob.stream !== \"function\") {\n            throw new Error(\"Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\\n\" +\n                \"If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body\");\n        }\n        return blob.stream();\n    };\n    return Object.assign(stream, {\n        transformToByteArray: transformToByteArray,\n        transformToString: async (encoding) => {\n            const buf = await transformToByteArray();\n            if (encoding === \"base64\") {\n                return toBase64(buf);\n            }\n            else if (encoding === \"hex\") {\n                return toHex(buf);\n            }\n            else if (encoding === undefined || encoding === \"utf8\" || encoding === \"utf-8\") {\n                return toUtf8(buf);\n            }\n            else if (typeof TextDecoder === \"function\") {\n                return new TextDecoder(encoding).decode(buf);\n            }\n            else {\n                throw new Error(\"TextDecoder is not available, please make sure polyfill is provided.\");\n            }\n        },\n        transformToWebStream: () => {\n            if (transformed) {\n                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);\n            }\n            transformed = true;\n            if (isBlobInstance(stream)) {\n                return blobToWebStream(stream);\n            }\n            else if (isReadableStream(stream)) {\n                return stream;\n            }\n            else {\n                throw new Error(`Cannot transform payload to web stream, got ${stream}`);\n            }\n        },\n    });\n};\nconst isBlobInstance = (stream) => typeof Blob === \"function\" && stream instanceof Blob;\n","import { fromBase64 } from \"@smithy/util-base64\";\nexport const streamCollector = async (stream) => {\n    if ((typeof Blob === \"function\" && stream instanceof Blob) || stream.constructor?.name === \"Blob\") {\n        if (Blob.prototype.arrayBuffer !== undefined) {\n            return new Uint8Array(await stream.arrayBuffer());\n        }\n        return collectBlob(stream);\n    }\n    return collectStream(stream);\n};\nasync function collectBlob(blob) {\n    const base64 = await readToBase64(blob);\n    const arrayBuffer = fromBase64(base64);\n    return new Uint8Array(arrayBuffer);\n}\nasync function collectStream(stream) {\n    const chunks = [];\n    const reader = stream.getReader();\n    let isDone = false;\n    let length = 0;\n    while (!isDone) {\n        const { done, value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            length += value.length;\n        }\n        isDone = done;\n    }\n    const collected = new Uint8Array(length);\n    let offset = 0;\n    for (const chunk of chunks) {\n        collected.set(chunk, offset);\n        offset += chunk.length;\n    }\n    return collected;\n}\nfunction readToBase64(blob) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n            if (reader.readyState !== 2) {\n                return reject(new Error(\"Reader aborted too early\"));\n            }\n            const result = (reader.result ?? \"\");\n            const commaIndex = result.indexOf(\",\");\n            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;\n            resolve(result.substring(dataOffset));\n        };\n        reader.onabort = () => reject(new Error(\"Read aborted\"));\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(blob);\n    });\n}\n","import { streamCollector } from \"@smithy/node-http-handler\";\nimport { fromArrayBuffer } from \"@smithy/util-buffer-from\";\nimport { Readable } from \"stream\";\nimport { sdkStreamMixin as sdkStreamMixinReadableStream } from \"./sdk-stream-mixin.browser\";\nconst ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = \"The stream has already been transformed.\";\nexport const sdkStreamMixin = (stream) => {\n    if (!(stream instanceof Readable)) {\n        try {\n            return sdkStreamMixinReadableStream(stream);\n        }\n        catch (e) {\n            const name = stream?.__proto__?.constructor?.name || stream;\n            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);\n        }\n    }\n    let transformed = false;\n    const transformToByteArray = async () => {\n        if (transformed) {\n            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);\n        }\n        transformed = true;\n        return await streamCollector(stream);\n    };\n    return Object.assign(stream, {\n        transformToByteArray,\n        transformToString: async (encoding) => {\n            const buf = await transformToByteArray();\n            if (encoding === undefined || Buffer.isEncoding(encoding)) {\n                return fromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);\n            }\n            else {\n                const decoder = new TextDecoder(encoding);\n                return decoder.decode(buf);\n            }\n        },\n        transformToWebStream: () => {\n            if (transformed) {\n                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);\n            }\n            if (stream.readableFlowing !== null) {\n                throw new Error(\"The stream has been consumed by other callbacks.\");\n            }\n            if (typeof Readable.toWeb !== \"function\") {\n                throw new Error(\"Readable.toWeb() is not supported. Please ensure a polyfill is available.\");\n            }\n            transformed = true;\n            return Readable.toWeb(stream);\n        },\n    });\n};\n","export const retryWrapper = (toRetry, maxRetries, delayMs) => {\n    return async () => {\n        for (let i = 0; i < maxRetries; ++i) {\n            try {\n                return await toRetry();\n            }\n            catch (e) {\n                await new Promise((resolve) => setTimeout(resolve, delayMs));\n            }\n        }\n        return await toRetry();\n    };\n};\n","import { setCredentialFeature } from \"@aws-sdk/core/client\";\nimport { NodeHttpHandler } from \"@smithy/node-http-handler\";\nimport { CredentialsProviderError } from \"@smithy/property-provider\";\nimport fs from \"fs/promises\";\nimport { checkUrl } from \"./checkUrl\";\nimport { createGetRequest, getCredentials } from \"./requestHelpers\";\nimport { retryWrapper } from \"./retry-wrapper\";\nconst AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = \"AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\";\nconst DEFAULT_LINK_LOCAL_HOST = \"http://169.254.170.2\";\nconst AWS_CONTAINER_CREDENTIALS_FULL_URI = \"AWS_CONTAINER_CREDENTIALS_FULL_URI\";\nconst AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = \"AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE\";\nconst AWS_CONTAINER_AUTHORIZATION_TOKEN = \"AWS_CONTAINER_AUTHORIZATION_TOKEN\";\nexport const fromHttp = (options = {}) => {\n    options.logger?.debug(\"@aws-sdk/credential-provider-http - fromHttp\");\n    let host;\n    const relative = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];\n    const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];\n    const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];\n    const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];\n    const warn = options.logger?.constructor?.name === \"NoOpLogger\" || !options.logger?.warn\n        ? console.warn\n        : options.logger.warn.bind(options.logger);\n    if (relative && full) {\n        warn(\"@aws-sdk/credential-provider-http: \" +\n            \"you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.\");\n        warn(\"awsContainerCredentialsFullUri will take precedence.\");\n    }\n    if (token && tokenFile) {\n        warn(\"@aws-sdk/credential-provider-http: \" +\n            \"you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.\");\n        warn(\"awsContainerAuthorizationToken will take precedence.\");\n    }\n    if (full) {\n        host = full;\n    }\n    else if (relative) {\n        host = `${DEFAULT_LINK_LOCAL_HOST}${relative}`;\n    }\n    else {\n        throw new CredentialsProviderError(`No HTTP credential provider host provided.\nSet AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });\n    }\n    const url = new URL(host);\n    checkUrl(url, options.logger);\n    const requestHandler = NodeHttpHandler.create({\n        requestTimeout: options.timeout ?? 1000,\n        connectionTimeout: options.timeout ?? 1000,\n    });\n    return retryWrapper(async () => {\n        const request = createGetRequest(url);\n        if (token) {\n            request.headers.Authorization = token;\n        }\n        else if (tokenFile) {\n            request.headers.Authorization = (await fs.readFile(tokenFile)).toString();\n        }\n        try {\n            const result = await requestHandler.handle(request);\n            return getCredentials(result.response).then((creds) => setCredentialFeature(creds, \"CREDENTIALS_HTTP\", \"z\"));\n        }\n        catch (e) {\n            throw new CredentialsProviderError(String(e), { logger: options.logger });\n        }\n    }, options.maxRetries ?? 3, options.timeout ?? 1000);\n};\n","import { CredentialsProviderError } from \"@smithy/property-provider\";\nconst LOOPBACK_CIDR_IPv4 = \"127.0.0.0/8\";\nconst LOOPBACK_CIDR_IPv6 = \"::1/128\";\nconst ECS_CONTAINER_HOST = \"169.254.170.2\";\nconst EKS_CONTAINER_HOST_IPv4 = \"169.254.170.23\";\nconst EKS_CONTAINER_HOST_IPv6 = \"[fd00:ec2::23]\";\nexport const checkUrl = (url, logger) => {\n    if (url.protocol === \"https:\") {\n        return;\n    }\n    if (url.hostname === ECS_CONTAINER_HOST ||\n        url.hostname === EKS_CONTAINER_HOST_IPv4 ||\n        url.hostname === EKS_CONTAINER_HOST_IPv6) {\n        return;\n    }\n    if (url.hostname.includes(\"[\")) {\n        if (url.hostname === \"[::1]\" || url.hostname === \"[0000:0000:0000:0000:0000:0000:0000:0001]\") {\n            return;\n        }\n    }\n    else {\n        if (url.hostname === \"localhost\") {\n            return;\n        }\n        const ipComponents = url.hostname.split(\".\");\n        const inRange = (component) => {\n            const num = parseInt(component, 10);\n            return 0 <= num && num <= 255;\n        };\n        if (ipComponents[0] === \"127\" &&\n            inRange(ipComponents[1]) &&\n            inRange(ipComponents[2]) &&\n            inRange(ipComponents[3]) &&\n            ipComponents.length === 4) {\n            return;\n        }\n    }\n    throw new CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:\n  - loopback CIDR 127.0.0.0/8 or [::1/128]\n  - ECS container host 169.254.170.2\n  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger });\n};\n","import { CredentialsProviderError } from \"@smithy/property-provider\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { parseRfc3339DateTime } from \"@smithy/smithy-client\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nexport function createGetRequest(url) {\n    return new HttpRequest({\n        protocol: url.protocol,\n        hostname: url.hostname,\n        port: Number(url.port),\n        path: url.pathname,\n        query: Array.from(url.searchParams.entries()).reduce((acc, [k, v]) => {\n            acc[k] = v;\n            return acc;\n        }, {}),\n        fragment: url.hash,\n    });\n}\nexport async function getCredentials(response, logger) {\n    const stream = sdkStreamMixin(response.body);\n    const str = await stream.transformToString();\n    if (response.statusCode === 200) {\n        const parsed = JSON.parse(str);\n        if (typeof parsed.AccessKeyId !== \"string\" ||\n            typeof parsed.SecretAccessKey !== \"string\" ||\n            typeof parsed.Token !== \"string\" ||\n            typeof parsed.Expiration !== \"string\") {\n            throw new CredentialsProviderError(\"HTTP credential provider response not of the required format, an object matching: \" +\n                \"{ AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }\", { logger });\n        }\n        return {\n            accessKeyId: parsed.AccessKeyId,\n            secretAccessKey: parsed.SecretAccessKey,\n            sessionToken: parsed.Token,\n            expiration: parseRfc3339DateTime(parsed.Expiration),\n        };\n    }\n    if (response.statusCode >= 400 && response.statusCode < 500) {\n        let parsedBody = {};\n        try {\n            parsedBody = JSON.parse(str);\n        }\n        catch (e) { }\n        throw Object.assign(new CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger }), {\n            Code: parsedBody.Code,\n            Message: parsedBody.Message,\n        });\n    }\n    throw new CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger });\n}\n"],"names":["NODEJS_TIMEOUT_ERROR_CODES","NodeHttpHandler","config","configProvider","socketWarningTimestamp","externalAgent","metadata","handlerProtocol","create","instanceOrOptions","handle","checkSocketUsage","agent","logger","console","sockets","requests","maxSockets","Infinity","Date","now","origin","socketsInUse","length","requestsEnqueued","warn","constructor","options","this","Promise","resolve","reject","then","_options","resolveDefaultConfig","catch","requestTimeout","connectionTimeout","socketTimeout","socketAcquisitionWarningTimeout","httpAgent","httpsAgent","throwOnRequestTimeout","keepAlive","destroy","request","abortSignal","_resolve","_reject","writeRequestBodyPromise","timeouts","async","arg","forEach","timing","clearTimeout","aborted","abortError","Error","name","isSSL","protocol","headers","expectContinue","Expect","expect","push","setTimeout","queryString","query","auth","username","password","path","fragment","hostname","endsWith","slice","nodeHttpsOptions","host","method","port","req","res","response","statusCode","reason","statusMessage","body","on","err","includes","code","Object","assign","onAbort","addEventListener","signal","once","removeEventListener","onabort","effectiveRequestTimeout","timeoutInMs","registerTimeout","offset","timeoutId","doWithSocket","socket","connecting","bind","setConnectionTimeout","msg","error","setRequestTimeout","timeout","onTimeout","removeListener","setSocketTimeout","keepAliveMsecs","deferTimeMs","registerListener","setKeepAlive","setSocketKeepAlive","e","updateHttpClientConfig","key","value","undefined","httpHandlerConfigs","isReadableStream","stream","ReadableStream","ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED","sdkStreamMixin","isBlobInstance","__proto__","transformed","transformToByteArray","Blob","prototype","arrayBuffer","Uint8Array","blob","base64","reader","FileReader","onloadend","readyState","result","commaIndex","indexOf","dataOffset","substring","onerror","readAsDataURL","readToBase64","fromBase64","collectBlob","chunks","getReader","isDone","done","read","collected","chunk","set","collectStream","streamCollector","transformToString","encoding","buf","toBase64","toUtf8","TextDecoder","decode","transformToWebStream","blobToWebStream","fromHttp","debug","relative","awsContainerCredentialsRelativeUri","process","env","full","awsContainerCredentialsFullUri","token","awsContainerAuthorizationToken","tokenFile","awsContainerAuthorizationTokenFile","CredentialsProviderError","C","url","URL","ipComponents","split","inRange","component","num","parseInt","checkUrl","requestHandler","toRetry","Number","pathname","Array","from","searchParams","entries","reduce","acc","k","v","hash","createGetRequest","Authorization","toString","Readable","Buffer","isEncoding","buffer","byteOffset","byteLength","readableFlowing","toWeb","str","parsed","JSON","parse","AccessKeyId","SecretAccessKey","Token","Expiration","accessKeyId","secretAccessKey","sessionToken","expiration","parsedBody","Code","Message","getCredentials","creds","setCredentialFeature","String","maxRetries","delayMs","i"],"ignoreList":[],"sourceRoot":""}